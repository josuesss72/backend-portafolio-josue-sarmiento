"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/plaiceholder";
exports.ids = ["vendor-chunks/plaiceholder"];
exports.modules = {

/***/ "(rsc)/./node_modules/plaiceholder/dist/plaiceholder.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/plaiceholder/dist/plaiceholder.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPlaiceholder: () => (/* binding */ getPlaiceholder)\n/* harmony export */ });\n/* harmony import */ var sharp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sharp */ \"sharp\");\n\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar _excluded = [\"a\"],\n    _excluded2 = [\"autoOrient\", \"size\", \"format\", \"brightness\", \"saturation\", \"removeAlpha\"],\n    _excluded3 = [\"width\", \"height\"];\n/* Utils\n   =========================================== */\n\nvar arrayChunk = function arrayChunk(arr, size) {\n  return arr.length > size ? [arr.slice(0, size)].concat(arrayChunk(arr.slice(size), size)) : [arr];\n};\n\nvar toRGBAString = function toRGBAString(_ref) {\n  var r = _ref.r,\n      g = _ref.g,\n      b = _ref.b,\n      a = _ref.a;\n  if (typeof a === \"undefined\") return \"rgb(\" + [r, g, b].join(\",\") + \")\";\n  return \"rgba(\" + [r, g, b, a].join(\",\") + \")\";\n};\n\nvar getPixels = function getPixels(_ref2) {\n  var _ref3;\n\n  var data = _ref2.data,\n      info = _ref2.info;\n  var channels = info.channels,\n      width = info.width;\n\n  var rawBuffer = (_ref3 = []).concat.apply(_ref3, data);\n\n  var allPixels = arrayChunk(rawBuffer, channels);\n  var rows = arrayChunk(allPixels, width);\n  var pixels = rows.map(function (row) {\n    return row.map(function (pixel) {\n      var r = pixel[0],\n          g = pixel[1],\n          b = pixel[2],\n          a = pixel[3];\n      return _extends({\n        r: r,\n        g: g,\n        b: b\n      }, typeof a === \"undefined\" ? {} : {\n        a: Math.round(a / 255 * 1000) / 1000\n      });\n    });\n  });\n  return pixels;\n};\n\nvar getCSS = function getCSS(_ref4) {\n  var pixels = _ref4.pixels,\n      info = _ref4.info;\n  var linearGradients = pixels.map(function (row) {\n    var rowPixels = row.map(function (pixel) {\n      return toRGBAString(pixel);\n    });\n    var gradient = rowPixels.map(function (pixel, i) {\n      var start = i === 0 ? \"\" : \" \" + i / rowPixels.length * 100 + \"%\";\n      var end = i === rowPixels.length ? \"\" : \" \" + (i + 1) / rowPixels.length * 100 + \"%\";\n      return \"\" + pixel + start + end;\n    }).join(\",\");\n    return \"linear-gradient(90deg, \" + gradient + \")\";\n  });\n\n  if (linearGradients.length !== info.height) {\n    console.error(\"Woops! Something went wrong here and caused the color height to differ from the source height.\");\n  }\n\n  var backgroundPosition = linearGradients.map(function (_, i) {\n    return i === 0 ? \"0 0 \" : \"0 \" + i / (linearGradients.length - 1) * 100 + \"%\";\n  }).join(\",\");\n  var backgroundSize = \"100% \" + 100 / linearGradients.length + \"%\";\n  return {\n    backgroundImage: linearGradients.join(\",\"),\n    backgroundPosition: backgroundPosition,\n    backgroundSize: backgroundSize,\n    backgroundRepeat: \"no-repeat\"\n  };\n};\n\nvar getSVG = function getSVG(_ref5) {\n  var _ref7;\n\n  var pixels = _ref5.pixels,\n      info = _ref5.info;\n  var chunkRects = pixels.map(function (row, y) {\n    return row.map(function (_ref6, x) {\n      var a = _ref6.a,\n          rgb = _objectWithoutPropertiesLoose(_ref6, _excluded);\n\n      var colorProps = typeof a !== \"undefined\" ? {\n        fill: toRGBAString(rgb),\n        \"fill-opacity\": a\n      } : {\n        fill: toRGBAString(rgb),\n        \"fill-opacity\": 1\n      };\n      return [\"rect\", _extends({}, colorProps, {\n        width: 1,\n        height: 1,\n        x: x,\n        y: y\n      })];\n    });\n  });\n\n  if (chunkRects.length !== info.height) {\n    console.error(\"Woops! Something went wrong here and caused the color height to differ from the source height.\");\n  }\n\n  var rects = (_ref7 = []).concat.apply(_ref7, chunkRects);\n\n  return [\"svg\", {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: \"100%\",\n    height: \"100%\",\n    shapeRendering: \"crispEdges\",\n    preserveAspectRatio: \"none\",\n    viewBox: \"0 0 \" + info.width + \" \" + info.height,\n    style: {\n      position: \"absolute\",\n      top: \"50%\",\n      left: \"50%\",\n      transformOrigin: \"top left\",\n      transform: \"translate(-50%, -50%)\",\n      right: 0,\n      bottom: 0\n    }\n  }, rects];\n};\n\nvar getPlaiceholder = function getPlaiceholder(src, _temp) {\n  var _ref8 = _temp === void 0 ? {} : _temp,\n      _ref8$autoOrient = _ref8.autoOrient,\n      autoOrient = _ref8$autoOrient === void 0 ? false : _ref8$autoOrient,\n      _ref8$size = _ref8.size,\n      size = _ref8$size === void 0 ? 4 : _ref8$size,\n      _ref8$format = _ref8.format,\n      format = _ref8$format === void 0 ? [\"png\"] : _ref8$format,\n      _ref8$brightness = _ref8.brightness,\n      brightness = _ref8$brightness === void 0 ? 1 : _ref8$brightness,\n      _ref8$saturation = _ref8.saturation,\n      saturation = _ref8$saturation === void 0 ? 1.2 : _ref8$saturation,\n      _ref8$removeAlpha = _ref8.removeAlpha,\n      removeAlpha = _ref8$removeAlpha === void 0 ? false : _ref8$removeAlpha,\n      options = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n\n  try {\n    /* Optimize\n      ---------------------------------- */\n    return Promise.resolve(sharp__WEBPACK_IMPORTED_MODULE_0__(src).metadata().then(function (_ref9) {\n      var width = _ref9.width,\n          height = _ref9.height,\n          metadata = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n\n      if (!width || !height) {\n        throw Error(\"Could not get required image metadata\");\n      }\n\n      return _extends({\n        width: width,\n        height: height\n      }, metadata);\n    })).then(function (metadata) {\n      var _sharp$resize;\n\n      var sizeMin = 4;\n      var sizeMax = 64;\n      var isSizeValid = sizeMin <= size && size <= sizeMax;\n      !isSizeValid && console.error([\"Please enter a `size` value between\", sizeMin, \"and\", sizeMax].join(\" \")); // initial optimization\n\n      var pipelineStage1 = (_sharp$resize = sharp__WEBPACK_IMPORTED_MODULE_0__(src).resize(size, size, {\n        fit: \"inside\"\n      })).toFormat.apply(_sharp$resize, format).modulate(_extends({\n        brightness: brightness,\n        saturation: saturation\n      }, options != null && options.hue ? {\n        hue: options == null ? void 0 : options.hue\n      } : {}, options != null && options.lightness ? {\n        lightness: options == null ? void 0 : options.lightness\n      } : {})); // alpha\n\n\n      var pipelineStage2 = removeAlpha === false ? pipelineStage1 : pipelineStage1.removeAlpha(); // autoOrientation\n\n      var pipelineStage3 = autoOrient === false ? pipelineStage2 : pipelineStage2.rotate();\n      var pipeline = pipelineStage3;\n      /* Return\n        ---------------------------------- */\n\n      return Promise.resolve(pipeline.clone().stats().then(function (_ref10) {\n        var _ref10$dominant = _ref10.dominant,\n            r = _ref10$dominant.r,\n            g = _ref10$dominant.g,\n            b = _ref10$dominant.b;\n        return {\n          r: r,\n          g: g,\n          b: b,\n          hex: \"#\" + [r, g, b].map(function (x) {\n            return x.toString(16).padStart(2, \"0\");\n          }).join(\"\")\n        };\n      })).then(function (color) {\n        return Promise.resolve(pipeline.clone().normalise().toBuffer({\n          resolveWithObject: true\n        }).then(function (_ref11) {\n          var data = _ref11.data,\n              info = _ref11.info;\n          return \"data:image/\" + info.format + \";base64,\" + data.toString(\"base64\");\n        })[\"catch\"](function (err) {\n          console.error(\"base64 generation failed\", err);\n          throw err;\n        })).then(function (base64) {\n          return Promise.resolve(pipeline.clone().raw().toBuffer({\n            resolveWithObject: true\n          }).then(function (_ref12) {\n            var data = _ref12.data,\n                info = _ref12.info;\n            var pixels = getPixels({\n              data: data,\n              info: info\n            });\n            var css = getCSS({\n              pixels: pixels,\n              info: info\n            });\n            var svg = getSVG({\n              pixels: pixels,\n              info: info\n            });\n            return {\n              pixels: pixels,\n              css: css,\n              svg: svg\n            };\n          })[\"catch\"](function (err) {\n            console.error(\"pixel generation failed\", err);\n            throw err;\n          })).then(function (_ref13) {\n            var pixels = _ref13.pixels,\n                css = _ref13.css,\n                svg = _ref13.svg;\n            return {\n              color: color,\n              css: css,\n              base64: base64,\n              metadata: metadata,\n              pixels: pixels,\n              svg: svg\n            };\n          });\n        });\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\n\n//# sourceMappingURL=plaiceholder.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGxhaWNlaG9sZGVyL2Rpc3QvcGxhaWNlaG9sZGVyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQjs7QUFFMUI7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnQ0FBZ0M7QUFDdkM7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0NBQUs7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSDs7QUFFakgsNENBQTRDLGtDQUFLO0FBQ2pEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxRQUFRLElBQUk7QUFDWjtBQUNBLFFBQVEsSUFBSSxJQUFJOzs7QUFHaEIsa0dBQWtHOztBQUVsRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUUyQjtBQUMzQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxKYWZldGggU2FybWllbnRvXFxEZXNrdG9wXFxwb3Jmb2xpby1uZXh0LXN0cmFwaVxcZnJvbnRlbmQtcG9yZm9saW9cXG5vZGVfbW9kdWxlc1xccGxhaWNlaG9sZGVyXFxkaXN0XFxwbGFpY2Vob2xkZXIuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzaGFycCBmcm9tICdzaGFycCc7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJhXCJdLFxuICAgIF9leGNsdWRlZDIgPSBbXCJhdXRvT3JpZW50XCIsIFwic2l6ZVwiLCBcImZvcm1hdFwiLCBcImJyaWdodG5lc3NcIiwgXCJzYXR1cmF0aW9uXCIsIFwicmVtb3ZlQWxwaGFcIl0sXG4gICAgX2V4Y2x1ZGVkMyA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdO1xuLyogVXRpbHNcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxudmFyIGFycmF5Q2h1bmsgPSBmdW5jdGlvbiBhcnJheUNodW5rKGFyciwgc2l6ZSkge1xuICByZXR1cm4gYXJyLmxlbmd0aCA+IHNpemUgPyBbYXJyLnNsaWNlKDAsIHNpemUpXS5jb25jYXQoYXJyYXlDaHVuayhhcnIuc2xpY2Uoc2l6ZSksIHNpemUpKSA6IFthcnJdO1xufTtcblxudmFyIHRvUkdCQVN0cmluZyA9IGZ1bmN0aW9uIHRvUkdCQVN0cmluZyhfcmVmKSB7XG4gIHZhciByID0gX3JlZi5yLFxuICAgICAgZyA9IF9yZWYuZyxcbiAgICAgIGIgPSBfcmVmLmIsXG4gICAgICBhID0gX3JlZi5hO1xuICBpZiAodHlwZW9mIGEgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBcInJnYihcIiArIFtyLCBnLCBiXS5qb2luKFwiLFwiKSArIFwiKVwiO1xuICByZXR1cm4gXCJyZ2JhKFwiICsgW3IsIGcsIGIsIGFdLmpvaW4oXCIsXCIpICsgXCIpXCI7XG59O1xuXG52YXIgZ2V0UGl4ZWxzID0gZnVuY3Rpb24gZ2V0UGl4ZWxzKF9yZWYyKSB7XG4gIHZhciBfcmVmMztcblxuICB2YXIgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBpbmZvID0gX3JlZjIuaW5mbztcbiAgdmFyIGNoYW5uZWxzID0gaW5mby5jaGFubmVscyxcbiAgICAgIHdpZHRoID0gaW5mby53aWR0aDtcblxuICB2YXIgcmF3QnVmZmVyID0gKF9yZWYzID0gW10pLmNvbmNhdC5hcHBseShfcmVmMywgZGF0YSk7XG5cbiAgdmFyIGFsbFBpeGVscyA9IGFycmF5Q2h1bmsocmF3QnVmZmVyLCBjaGFubmVscyk7XG4gIHZhciByb3dzID0gYXJyYXlDaHVuayhhbGxQaXhlbHMsIHdpZHRoKTtcbiAgdmFyIHBpeGVscyA9IHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICByZXR1cm4gcm93Lm1hcChmdW5jdGlvbiAocGl4ZWwpIHtcbiAgICAgIHZhciByID0gcGl4ZWxbMF0sXG4gICAgICAgICAgZyA9IHBpeGVsWzFdLFxuICAgICAgICAgIGIgPSBwaXhlbFsyXSxcbiAgICAgICAgICBhID0gcGl4ZWxbM107XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICByOiByLFxuICAgICAgICBnOiBnLFxuICAgICAgICBiOiBiXG4gICAgICB9LCB0eXBlb2YgYSA9PT0gXCJ1bmRlZmluZWRcIiA/IHt9IDoge1xuICAgICAgICBhOiBNYXRoLnJvdW5kKGEgLyAyNTUgKiAxMDAwKSAvIDEwMDBcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHBpeGVscztcbn07XG5cbnZhciBnZXRDU1MgPSBmdW5jdGlvbiBnZXRDU1MoX3JlZjQpIHtcbiAgdmFyIHBpeGVscyA9IF9yZWY0LnBpeGVscyxcbiAgICAgIGluZm8gPSBfcmVmNC5pbmZvO1xuICB2YXIgbGluZWFyR3JhZGllbnRzID0gcGl4ZWxzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgdmFyIHJvd1BpeGVscyA9IHJvdy5tYXAoZnVuY3Rpb24gKHBpeGVsKSB7XG4gICAgICByZXR1cm4gdG9SR0JBU3RyaW5nKHBpeGVsKTtcbiAgICB9KTtcbiAgICB2YXIgZ3JhZGllbnQgPSByb3dQaXhlbHMubWFwKGZ1bmN0aW9uIChwaXhlbCwgaSkge1xuICAgICAgdmFyIHN0YXJ0ID0gaSA9PT0gMCA/IFwiXCIgOiBcIiBcIiArIGkgLyByb3dQaXhlbHMubGVuZ3RoICogMTAwICsgXCIlXCI7XG4gICAgICB2YXIgZW5kID0gaSA9PT0gcm93UGl4ZWxzLmxlbmd0aCA/IFwiXCIgOiBcIiBcIiArIChpICsgMSkgLyByb3dQaXhlbHMubGVuZ3RoICogMTAwICsgXCIlXCI7XG4gICAgICByZXR1cm4gXCJcIiArIHBpeGVsICsgc3RhcnQgKyBlbmQ7XG4gICAgfSkuam9pbihcIixcIik7XG4gICAgcmV0dXJuIFwibGluZWFyLWdyYWRpZW50KDkwZGVnLCBcIiArIGdyYWRpZW50ICsgXCIpXCI7XG4gIH0pO1xuXG4gIGlmIChsaW5lYXJHcmFkaWVudHMubGVuZ3RoICE9PSBpbmZvLmhlaWdodCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJXb29wcyEgU29tZXRoaW5nIHdlbnQgd3JvbmcgaGVyZSBhbmQgY2F1c2VkIHRoZSBjb2xvciBoZWlnaHQgdG8gZGlmZmVyIGZyb20gdGhlIHNvdXJjZSBoZWlnaHQuXCIpO1xuICB9XG5cbiAgdmFyIGJhY2tncm91bmRQb3NpdGlvbiA9IGxpbmVhckdyYWRpZW50cy5tYXAoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICByZXR1cm4gaSA9PT0gMCA/IFwiMCAwIFwiIDogXCIwIFwiICsgaSAvIChsaW5lYXJHcmFkaWVudHMubGVuZ3RoIC0gMSkgKiAxMDAgKyBcIiVcIjtcbiAgfSkuam9pbihcIixcIik7XG4gIHZhciBiYWNrZ3JvdW5kU2l6ZSA9IFwiMTAwJSBcIiArIDEwMCAvIGxpbmVhckdyYWRpZW50cy5sZW5ndGggKyBcIiVcIjtcbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IGxpbmVhckdyYWRpZW50cy5qb2luKFwiLFwiKSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb246IGJhY2tncm91bmRQb3NpdGlvbixcbiAgICBiYWNrZ3JvdW5kU2l6ZTogYmFja2dyb3VuZFNpemUsXG4gICAgYmFja2dyb3VuZFJlcGVhdDogXCJuby1yZXBlYXRcIlxuICB9O1xufTtcblxudmFyIGdldFNWRyA9IGZ1bmN0aW9uIGdldFNWRyhfcmVmNSkge1xuICB2YXIgX3JlZjc7XG5cbiAgdmFyIHBpeGVscyA9IF9yZWY1LnBpeGVscyxcbiAgICAgIGluZm8gPSBfcmVmNS5pbmZvO1xuICB2YXIgY2h1bmtSZWN0cyA9IHBpeGVscy5tYXAoZnVuY3Rpb24gKHJvdywgeSkge1xuICAgIHJldHVybiByb3cubWFwKGZ1bmN0aW9uIChfcmVmNiwgeCkge1xuICAgICAgdmFyIGEgPSBfcmVmNi5hLFxuICAgICAgICAgIHJnYiA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY2LCBfZXhjbHVkZWQpO1xuXG4gICAgICB2YXIgY29sb3JQcm9wcyA9IHR5cGVvZiBhICE9PSBcInVuZGVmaW5lZFwiID8ge1xuICAgICAgICBmaWxsOiB0b1JHQkFTdHJpbmcocmdiKSxcbiAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogYVxuICAgICAgfSA6IHtcbiAgICAgICAgZmlsbDogdG9SR0JBU3RyaW5nKHJnYiksXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IDFcbiAgICAgIH07XG4gICAgICByZXR1cm4gW1wicmVjdFwiLCBfZXh0ZW5kcyh7fSwgY29sb3JQcm9wcywge1xuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KV07XG4gICAgfSk7XG4gIH0pO1xuXG4gIGlmIChjaHVua1JlY3RzLmxlbmd0aCAhPT0gaW5mby5oZWlnaHQpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiV29vcHMhIFNvbWV0aGluZyB3ZW50IHdyb25nIGhlcmUgYW5kIGNhdXNlZCB0aGUgY29sb3IgaGVpZ2h0IHRvIGRpZmZlciBmcm9tIHRoZSBzb3VyY2UgaGVpZ2h0LlwiKTtcbiAgfVxuXG4gIHZhciByZWN0cyA9IChfcmVmNyA9IFtdKS5jb25jYXQuYXBwbHkoX3JlZjcsIGNodW5rUmVjdHMpO1xuXG4gIHJldHVybiBbXCJzdmdcIiwge1xuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgc2hhcGVSZW5kZXJpbmc6IFwiY3Jpc3BFZGdlc1wiLFxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IFwibm9uZVwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIFwiICsgaW5mby53aWR0aCArIFwiIFwiICsgaW5mby5oZWlnaHQsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICB0b3A6IFwiNTAlXCIsXG4gICAgICBsZWZ0OiBcIjUwJVwiLFxuICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcInRvcCBsZWZ0XCIsXG4gICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKC01MCUsIC01MCUpXCIsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH1cbiAgfSwgcmVjdHNdO1xufTtcblxudmFyIGdldFBsYWljZWhvbGRlciA9IGZ1bmN0aW9uIGdldFBsYWljZWhvbGRlcihzcmMsIF90ZW1wKSB7XG4gIHZhciBfcmVmOCA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgX3JlZjgkYXV0b09yaWVudCA9IF9yZWY4LmF1dG9PcmllbnQsXG4gICAgICBhdXRvT3JpZW50ID0gX3JlZjgkYXV0b09yaWVudCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmOCRhdXRvT3JpZW50LFxuICAgICAgX3JlZjgkc2l6ZSA9IF9yZWY4LnNpemUsXG4gICAgICBzaXplID0gX3JlZjgkc2l6ZSA9PT0gdm9pZCAwID8gNCA6IF9yZWY4JHNpemUsXG4gICAgICBfcmVmOCRmb3JtYXQgPSBfcmVmOC5mb3JtYXQsXG4gICAgICBmb3JtYXQgPSBfcmVmOCRmb3JtYXQgPT09IHZvaWQgMCA/IFtcInBuZ1wiXSA6IF9yZWY4JGZvcm1hdCxcbiAgICAgIF9yZWY4JGJyaWdodG5lc3MgPSBfcmVmOC5icmlnaHRuZXNzLFxuICAgICAgYnJpZ2h0bmVzcyA9IF9yZWY4JGJyaWdodG5lc3MgPT09IHZvaWQgMCA/IDEgOiBfcmVmOCRicmlnaHRuZXNzLFxuICAgICAgX3JlZjgkc2F0dXJhdGlvbiA9IF9yZWY4LnNhdHVyYXRpb24sXG4gICAgICBzYXR1cmF0aW9uID0gX3JlZjgkc2F0dXJhdGlvbiA9PT0gdm9pZCAwID8gMS4yIDogX3JlZjgkc2F0dXJhdGlvbixcbiAgICAgIF9yZWY4JHJlbW92ZUFscGhhID0gX3JlZjgucmVtb3ZlQWxwaGEsXG4gICAgICByZW1vdmVBbHBoYSA9IF9yZWY4JHJlbW92ZUFscGhhID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWY4JHJlbW92ZUFscGhhLFxuICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY4LCBfZXhjbHVkZWQyKTtcblxuICB0cnkge1xuICAgIC8qIE9wdGltaXplXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzaGFycChzcmMpLm1ldGFkYXRhKCkudGhlbihmdW5jdGlvbiAoX3JlZjkpIHtcbiAgICAgIHZhciB3aWR0aCA9IF9yZWY5LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9yZWY5LmhlaWdodCxcbiAgICAgICAgICBtZXRhZGF0YSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY5LCBfZXhjbHVkZWQzKTtcblxuICAgICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGdldCByZXF1aXJlZCBpbWFnZSBtZXRhZGF0YVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfSwgbWV0YWRhdGEpO1xuICAgIH0pKS50aGVuKGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgICAgdmFyIF9zaGFycCRyZXNpemU7XG5cbiAgICAgIHZhciBzaXplTWluID0gNDtcbiAgICAgIHZhciBzaXplTWF4ID0gNjQ7XG4gICAgICB2YXIgaXNTaXplVmFsaWQgPSBzaXplTWluIDw9IHNpemUgJiYgc2l6ZSA8PSBzaXplTWF4O1xuICAgICAgIWlzU2l6ZVZhbGlkICYmIGNvbnNvbGUuZXJyb3IoW1wiUGxlYXNlIGVudGVyIGEgYHNpemVgIHZhbHVlIGJldHdlZW5cIiwgc2l6ZU1pbiwgXCJhbmRcIiwgc2l6ZU1heF0uam9pbihcIiBcIikpOyAvLyBpbml0aWFsIG9wdGltaXphdGlvblxuXG4gICAgICB2YXIgcGlwZWxpbmVTdGFnZTEgPSAoX3NoYXJwJHJlc2l6ZSA9IHNoYXJwKHNyYykucmVzaXplKHNpemUsIHNpemUsIHtcbiAgICAgICAgZml0OiBcImluc2lkZVwiXG4gICAgICB9KSkudG9Gb3JtYXQuYXBwbHkoX3NoYXJwJHJlc2l6ZSwgZm9ybWF0KS5tb2R1bGF0ZShfZXh0ZW5kcyh7XG4gICAgICAgIGJyaWdodG5lc3M6IGJyaWdodG5lc3MsXG4gICAgICAgIHNhdHVyYXRpb246IHNhdHVyYXRpb25cbiAgICAgIH0sIG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmh1ZSA/IHtcbiAgICAgICAgaHVlOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmh1ZVxuICAgICAgfSA6IHt9LCBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5saWdodG5lc3MgPyB7XG4gICAgICAgIGxpZ2h0bmVzczogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5saWdodG5lc3NcbiAgICAgIH0gOiB7fSkpOyAvLyBhbHBoYVxuXG5cbiAgICAgIHZhciBwaXBlbGluZVN0YWdlMiA9IHJlbW92ZUFscGhhID09PSBmYWxzZSA/IHBpcGVsaW5lU3RhZ2UxIDogcGlwZWxpbmVTdGFnZTEucmVtb3ZlQWxwaGEoKTsgLy8gYXV0b09yaWVudGF0aW9uXG5cbiAgICAgIHZhciBwaXBlbGluZVN0YWdlMyA9IGF1dG9PcmllbnQgPT09IGZhbHNlID8gcGlwZWxpbmVTdGFnZTIgOiBwaXBlbGluZVN0YWdlMi5yb3RhdGUoKTtcbiAgICAgIHZhciBwaXBlbGluZSA9IHBpcGVsaW5lU3RhZ2UzO1xuICAgICAgLyogUmV0dXJuXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwaXBlbGluZS5jbG9uZSgpLnN0YXRzKCkudGhlbihmdW5jdGlvbiAoX3JlZjEwKSB7XG4gICAgICAgIHZhciBfcmVmMTAkZG9taW5hbnQgPSBfcmVmMTAuZG9taW5hbnQsXG4gICAgICAgICAgICByID0gX3JlZjEwJGRvbWluYW50LnIsXG4gICAgICAgICAgICBnID0gX3JlZjEwJGRvbWluYW50LmcsXG4gICAgICAgICAgICBiID0gX3JlZjEwJGRvbWluYW50LmI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogcixcbiAgICAgICAgICBnOiBnLFxuICAgICAgICAgIGI6IGIsXG4gICAgICAgICAgaGV4OiBcIiNcIiArIFtyLCBnLCBiXS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4LnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG4gICAgICAgICAgfSkuam9pbihcIlwiKVxuICAgICAgICB9O1xuICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGlwZWxpbmUuY2xvbmUoKS5ub3JtYWxpc2UoKS50b0J1ZmZlcih7XG4gICAgICAgICAgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWVcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX3JlZjExKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBfcmVmMTEuZGF0YSxcbiAgICAgICAgICAgICAgaW5mbyA9IF9yZWYxMS5pbmZvO1xuICAgICAgICAgIHJldHVybiBcImRhdGE6aW1hZ2UvXCIgKyBpbmZvLmZvcm1hdCArIFwiO2Jhc2U2NCxcIiArIGRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJiYXNlNjQgZ2VuZXJhdGlvbiBmYWlsZWRcIiwgZXJyKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pKS50aGVuKGZ1bmN0aW9uIChiYXNlNjQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBpcGVsaW5lLmNsb25lKCkucmF3KCkudG9CdWZmZXIoe1xuICAgICAgICAgICAgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWVcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfcmVmMTIpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gX3JlZjEyLmRhdGEsXG4gICAgICAgICAgICAgICAgaW5mbyA9IF9yZWYxMi5pbmZvO1xuICAgICAgICAgICAgdmFyIHBpeGVscyA9IGdldFBpeGVscyh7XG4gICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgIGluZm86IGluZm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGNzcyA9IGdldENTUyh7XG4gICAgICAgICAgICAgIHBpeGVsczogcGl4ZWxzLFxuICAgICAgICAgICAgICBpbmZvOiBpbmZvXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzdmcgPSBnZXRTVkcoe1xuICAgICAgICAgICAgICBwaXhlbHM6IHBpeGVscyxcbiAgICAgICAgICAgICAgaW5mbzogaW5mb1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwaXhlbHM6IHBpeGVscyxcbiAgICAgICAgICAgICAgY3NzOiBjc3MsXG4gICAgICAgICAgICAgIHN2Zzogc3ZnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInBpeGVsIGdlbmVyYXRpb24gZmFpbGVkXCIsIGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKF9yZWYxMykge1xuICAgICAgICAgICAgdmFyIHBpeGVscyA9IF9yZWYxMy5waXhlbHMsXG4gICAgICAgICAgICAgICAgY3NzID0gX3JlZjEzLmNzcyxcbiAgICAgICAgICAgICAgICBzdmcgPSBfcmVmMTMuc3ZnO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICBjc3M6IGNzcyxcbiAgICAgICAgICAgICAgYmFzZTY0OiBiYXNlNjQsXG4gICAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgcGl4ZWxzOiBwaXhlbHMsXG4gICAgICAgICAgICAgIHN2Zzogc3ZnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICB9XG59O1xuXG5leHBvcnQgeyBnZXRQbGFpY2Vob2xkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsYWljZWhvbGRlci5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/plaiceholder/dist/plaiceholder.esm.js\n");

/***/ })

};
;